#!/usr/bin/env python3
"""
Script to migrate secrets from local database to remote server.

This script:
1. Reads secrets from local secrets.db
2. Decrypts them using local encryption key
3. Transfers them to the server
4. Imports them using the server's encryption key

Usage:
    python migrate_secrets.py [host] [user] [app_dir]
    
Defaults:
    host: 192.168.1.224
    user: jexida
    app_dir: /opt/jexida-mcp

Output Files:
    - migration_log.txt: Detailed log of the migration process
    - tmp/migration_exec_result.json: JSON result from import script execution
    - tmp/migration_summary.json: Summary of migration (success, counts, etc.)

Note: This script uses get_ssh_output.py to capture SSH command output,
      so you can check the JSON files even if terminal output isn't visible.
"""
import sys
import json
import os
import importlib
import subprocess
from pathlib import Path

# Add mcp_server_files to path
sys.path.insert(0, str(Path(__file__).parent / "mcp_server_files"))

from jexida_cli.ssh_client import SSHClient


def get_local_secrets():
    """Read all secrets from local database."""
    # Check for local secrets.db in root directory or mcp_server_files
    root_dir = Path(__file__).parent
    local_db_path = root_dir / "secrets.db"
    server_db_path = root_dir / "mcp_server_files" / "secrets.db"
    
    # Check which database actually has the secrets table
    db_path = None
    import sqlite3
    
    # Check root database first
    if local_db_path.exists():
        try:
            conn = sqlite3.connect(str(local_db_path))
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='secrets'")
            if cursor.fetchone():
                db_path = local_db_path
            conn.close()
        except Exception:
            pass
    
    # If root doesn't have secrets table, check mcp_server_files
    if db_path is None and server_db_path.exists():
        try:
            conn = sqlite3.connect(str(server_db_path))
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='secrets'")
            if cursor.fetchone():
                db_path = server_db_path
            conn.close()
        except Exception:
            pass
    
    if db_path is None:
        print(f"Error: No secrets.db with secrets table found at {local_db_path} or {server_db_path}")
        return []
    
    print(f"Using database at: {db_path}")
    
    # Directly connect to local database
    from sqlalchemy import create_engine
    from sqlalchemy.orm import sessionmaker
    
    # Import Secret model
    from database import Secret, Base
    
    # Create engine pointing to local database
    db_url = f"sqlite:///{db_path}"
    engine = create_engine(db_url, connect_args={"check_same_thread": False})
    SessionLocal = sessionmaker(bind=engine)
    
    # Temporarily set environment for encryption key
    # Change to the directory containing the database
    original_cwd = os.getcwd()
    os.chdir(db_path.parent)
    
    try:
        # Load encryption key from local environment
        from database import decrypt_value
        
        db = SessionLocal()
        secrets = db.query(Secret).all()
        
        result = []
        for secret in secrets:
            try:
                # Decrypt using local encryption key
                decrypted_value = decrypt_value(secret.encrypted_value)
                result.append({
                    "name": secret.name,
                    "service_type": secret.service_type,
                    "key": secret.key,
                    "value": decrypted_value,
                    "created_at": secret.created_at.isoformat() if secret.created_at else None,
                    "updated_at": secret.updated_at.isoformat() if secret.updated_at else None,
                })
            except Exception as e:
                print(f"Warning: Could not decrypt secret {secret.name}/{secret.key}: {e}")
                continue
        
        db.close()
        return result
    finally:
        # Restore original working directory
        os.chdir(original_cwd)


def create_import_script(secrets_data):
    """Create a Python script to import secrets on the server."""
    secrets_json = json.dumps(secrets_data, indent=2)
    script_content = f'''#!/usr/bin/env python3
"""
Temporary script to import secrets into server database.
Generated by migrate_secrets.py
"""
import sys
import os
from pathlib import Path

# Add app directory to path
sys.path.insert(0, str(Path(__file__).parent))

from database import Secret, get_db, encrypt_value, get_session_local

# Secrets to import
SECRETS_DATA = {secrets_json}

def main():
    """Import secrets into database."""
    db = next(get_db())
    imported = 0
    skipped = 0
    errors = 0
    
    try:
        for secret_data in SECRETS_DATA:
            try:
                # Check if secret already exists
                existing = db.query(Secret).filter(
                    Secret.service_type == secret_data["service_type"],
                    Secret.key == secret_data["key"]
                ).first()
                
                if existing:
                    print(f"Skipping {{secret_data['service_type']}}/{{secret_data['key']}} (already exists)")
                    skipped += 1
                    continue
                
                # Encrypt value using server's encryption key
                encrypted_value = encrypt_value(secret_data["value"])
                
                # Create new secret
                secret = Secret(
                    name=secret_data["name"],
                    service_type=secret_data["service_type"],
                    key=secret_data["key"],
                    encrypted_value=encrypted_value
                )
                
                db.add(secret)
                imported += 1
                print(f"Imported {{secret_data['name']}} ({{secret_data['service_type']}}/{{secret_data['key']}})")
                
            except Exception as e:
                print(f"Error importing {{secret_data.get('name', 'unknown')}}: {{e}}")
                errors += 1
        
        db.commit()
        print(f"\\nImport complete: {{imported}} imported, {{skipped}} skipped, {{errors}} errors")
        
    except Exception as e:
        db.rollback()
        print(f"Error during import: {{e}}")
        sys.exit(1)
    finally:
        db.close()

if __name__ == "__main__":
    main()
'''
    return script_content


def main():
    """Main migration function."""
    # Parse arguments
    host = sys.argv[1] if len(sys.argv) > 1 else "192.168.1.224"
    user = sys.argv[2] if len(sys.argv) > 2 else "jexida"
    app_dir = sys.argv[3] if len(sys.argv) > 3 else "/opt/jexida-mcp"
    
    # Also write to log file
    log_file = Path("migration_log.txt")
    log_f = open(log_file, "w", encoding="utf-8")
    
    def log_print(msg, end="\n"):
        print(msg, end=end, flush=True)
        log_f.write(msg + end)
        log_f.flush()
    
    log_print("=" * 60)
    log_print("Secret Migration Script")
    log_print("=" * 60)
    log_print(f"Host: {host}")
    log_print(f"User: {user}")
    log_print(f"App Directory: {app_dir}")
    log_print("")
    
    try:
        # Step 1: Read local secrets
        log_print("Step 1: Reading secrets from local database...")
        try:
            local_secrets = get_local_secrets()
        except Exception as e:
            log_print(f"Error reading local secrets: {e}")
            import traceback
            log_print(traceback.format_exc())
            log_f.close()
            return 1
        
        if not local_secrets:
            log_print("No secrets found in local database.")
            log_print("If you expected secrets to be there, check:")
            log_print("  1. The database file exists (secrets.db or mcp_server_files/secrets.db)")
            log_print("  2. The SECRET_ENCRYPTION_KEY environment variable is set correctly")
            log_f.close()
            return 0
        
        log_print(f"Found {len(local_secrets)} secret(s):")
        for secret in local_secrets:
            log_print(f"  - {secret['name']} ({secret['service_type']}/{secret['key']})")
        log_print("")
    
        # Step 2: Create import script
        log_print("Step 2: Creating import script...")
        import_script = create_import_script(local_secrets)
        
        # Save script locally temporarily
        temp_script = Path("tmp_import_secrets.py")
        temp_script.parent.mkdir(exist_ok=True)
        with open(temp_script, "w", encoding="utf-8") as f:
            f.write(import_script)
        log_print(f"Created temporary script: {temp_script}")
        log_print("")
        
        # Step 3: Copy script to server
        log_print("Step 3: Copying import script to server...")
        import subprocess
        remote_script_path = f"{app_dir}/tmp_import_secrets.py"
        
        scp_command = [
            "scp",
            str(temp_script),
            f"{user}@{host}:{remote_script_path}"
        ]
        
        try:
            result = subprocess.run(
                scp_command,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode != 0:
                log_print(f"Error copying script: {result.stderr}")
                log_f.close()
                return 1
            
            log_print(f"Script copied to {remote_script_path}")
            log_print("")
        except Exception as e:
            log_print(f"Error: {e}")
            log_f.close()
            return 1
        
        # Step 4: Execute import script on server
        log_print("Step 4: Executing import script on server...")
        
        # Use get_ssh_output.py to capture output in JSON
        # Use venv Python to ensure dependencies are available
        command = f"cd {app_dir} && {app_dir}/venv/bin/python3 tmp_import_secrets.py"
        result_file = Path("tmp/migration_exec_result.json")
        result_file.parent.mkdir(exist_ok=True)
        
        # Use get_ssh_output.py helper script
        get_ssh_output_script = Path(__file__).parent / "get_ssh_output.py"
        ssh_cmd = [
            "python3",
            str(get_ssh_output_script),
            host,
            user,
            command,
            str(result_file)
        ]
        
        try:
            result = subprocess.run(ssh_cmd, capture_output=True, text=True, timeout=300)
            if result.returncode != 0:
                log_print(f"Error running SSH command: {result.stderr}")
                log_f.close()
                return 1
            
            # Read the JSON result
            if result_file.exists():
                with open(result_file, "r", encoding="utf-8") as f:
                    exec_result = json.load(f)
                
                log_print(exec_result.get("stdout", ""))
                if exec_result.get("stderr"):
                    log_print(f"Stderr: {exec_result['stderr']}")
                
                if not exec_result.get("success", False):
                    log_print(f"Error: Import script failed with exit code {exec_result.get('exit_code', -1)}")
                    log_f.close()
                    return 1
            else:
                log_print("Warning: Could not read execution result file")
        except Exception as e:
            log_print(f"Error executing import script: {e}")
            log_f.close()
            return 1
        
        # Step 5: Clean up
        log_print("")
        log_print("Step 5: Cleaning up...")
        
        # Remove remote script using get_ssh_output.py
        cleanup_command = f"rm -f {remote_script_path}"
        cleanup_result_file = Path("tmp/migration_cleanup_result.json")
        cleanup_cmd = [
            "python3",
            str(get_ssh_output_script),
            host,
            user,
            cleanup_command,
            str(cleanup_result_file)
        ]
        subprocess.run(cleanup_cmd, capture_output=True, text=True, timeout=60)
        
        # Remove local script
        temp_script.unlink()
        
        log_print("Cleanup complete.")
        log_print("")
        log_print("=" * 60)
        log_print("Migration complete!")
        log_print("=" * 60)
        
        # Write summary JSON file
        summary = {
            "success": True,
            "host": host,
            "user": user,
            "app_dir": app_dir,
            "secrets_found": len(local_secrets),
            "secrets_migrated": len(local_secrets),
            "log_file": str(log_file),
            "execution_result_file": str(result_file) if result_file.exists() else None
        }
        summary_file = Path("tmp/migration_summary.json")
        summary_file.parent.mkdir(exist_ok=True)
        with open(summary_file, "w", encoding="utf-8") as f:
            json.dump(summary, f, indent=2)
        
        log_print(f"\nSummary written to: {summary_file}")
        log_f.close()
        return 0
    finally:
        if 'log_f' in locals() and not log_f.closed:
            log_f.close()


if __name__ == "__main__":
    try:
        exit_code = main()
        sys.exit(exit_code)
    except Exception as e:
        print(f"Fatal error: {e}", file=sys.stderr, flush=True)
        import traceback
        traceback.print_exc()
        sys.exit(1)

